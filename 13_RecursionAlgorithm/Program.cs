// //Двумерные массивы
// string[,] table = new string[2,5]; //задается таблица строк
// // string - тип данных
// // [,] - показывает, что будет 2 размерности (запятая): строки и столбцы
// // table - наименование массива (имя)
// // new string[2,3]; - сколько будет строк (2) и столбцов (5)

// // String.Empty - инициализация строк по умолчанию - "пусто" (они есть но в них ничего нет)
// // Индексы строк и столбцов меняются от 0 (нуля)!:
// // // table[0,0] table[0,1] table[0,2] table[0,3] table[0,4]
// // // table[1,0] table[1,1] table[1,2] table[1,3] table[1,4]

// table[1,2] = "слово";  //обращение к нужному элементу двумерного массива
// // - указываем № строки(1) и столбца (2) и можем присвоить значение (="слово")
// // цикл для распечатки массива, rows - строки:
// for (int rows = 0; rows < 2; rows++)
// {   // вложенный цикл для столбцов - columns (их пять):
//     for (int columns = 0; columns < 5; columns++)
//     {   // распечатка с интерполяцией:
//         Console.WriteLine($"-{table[rows, columns]}-");
//         // - обращение к элементам массива через имя массива и индекс строки и столбца
//         // - сделано обрамление "-" чтобы было видно пустую ячейку (выводилась на печать)
//     }
// }



// // зададим числовой массив:
// int[,] matrix = new int [3,4];  //двумерный массив matrix из 3 строк и 4 столбцов
// // - *!определяем сколько памяти выделять на массив - [3,4]!*
// for (int i = 0; i < 3; i++)  //внешний цикл щелкающий строки
// {
//     for (int j = 0; j < 4; j++)  //внутренний цикл щелкающий столбцы
//     {
//         Console.Write($"{matrix[i,j]} ");  //вывод на экран интерполяцией через пробел (на одной строке)
//     }
// Console.WriteLine();  // переход вывода на новую строку (после печати строки массива)
// // - для красивого вывода матрицы в виде матрицы (таблицы)
// }



// Создадим метод для печати и заполнения массива
// зададим цикл для любого размера массива (тот же пример):
 
// void PrintArray(int[,] matr)  //в метод, в качестве аргумента передаем прямоугольную таблицу чисел
// {
// // matrix.GetLength(0) - обращение к количеству строк (именно 0):
//     for (int i = 0; i < matr.GetLength(0); i++)  
//     {
//         // matrix.GetLength(1) - обращение к количеству столбцов (именно 1):
//         for (int j = 0; j < matr.GetLength(1); j++)  
//         {
//             Console.Write($"{matr[i,j]} ");
//         }
//         Console.WriteLine();
//     }
// }
// // дополнительный метод для заполнения массива числами:
// void FilltArray(int[,] matr)  
// {
//     for (int i = 0; i < matr.GetLength(0); i++)  
//     {
//         for (int j = 0; j < matr.GetLength(1); j++)  
//         {
//             matr[i,j] = new Random().Next(1,10);  //генератор псевдослучайных чисел от 1 до 9
//             // обращение к конкретному элементу массива на позиции [i,j]
//         }
//     }
// }
// int[,] matrix = new int [3,4];  // инициализация массива, перенесли вниз для компактности кода
// PrintArray(matrix);  // печать - убедимся что есть нолики
// FilltArray(matrix);  // заполнение массива числами
// Console.WriteLine(); // разделение массивов строкой
// PrintArray(matrix);  // печать заполненного массива



// // Отрисовка двумерного массива, состоящего из нулей и едениц
// // Для начала, задаем массив "ручками" [10,14]:
// int[,] pic = new int [,]
// {
//     {0,0,0,0,1,1,1,1,1,1,0,0,0,0},
//     {0,0,0,0,1,0,0,0,0,1,0,0,0,0},
//     {0,0,0,0,1,0,0,0,0,1,0,0,0,0},
//     {1,1,1,1,1,0,0,0,0,1,1,1,1,1},
//     {1,0,0,0,0,0,0,0,0,0,0,0,0,1},
//     {1,0,0,0,0,0,0,0,0,0,0,0,0,1},
//     {1,1,1,1,1,0,0,0,0,1,1,1,1,1},
//     {0,0,0,0,1,0,0,0,0,1,0,0,0,0},
//     {0,0,0,0,1,0,0,0,0,1,0,0,0,0},
//     {0,0,0,0,1,1,1,1,1,1,0,0,0,0},
// };
// // Метод, который будет выводить массив "более интересно":
// void PrintImage(int[,] image) 
// {
//     for (int i = 0; i < image.GetLength(0); i++)  
//     {
//         for (int j = 0; j < image.GetLength(1); j++)  
//         {
//             if(image[i,j] == 0) Console.Write($" ");
//             // - если елемент массива равен нулю - печатать пробел (пустоту)
//             else Console.Write($"+");
//             // - если елемент массива равен еденице - печатать "плюсик"
//         }
//         Console.WriteLine();  // новая строка печатается на новой строке
//     }
// }
// // PrintImage(pic);  // вызов метода (печати массива) для массива pic

// // Метод, который будет закрашивать картинку
// void FillImage(int row, int col)  // аргументы: позиция строки и пикселя
// // - с которого мы начнем закраску рисунка
// {
//     if (pic[row, col] == 0)  // если текущий пиксель равен нулю
//     {
//         pic[row, col] = 1;  // закрасим его еденичкой
//         // вызываем метод сам на себя и описываем последовательность действий (рекурсия):
//         FillImage( row - 1,  col);  //  поднимаемся на строчку выше (от начального пикселя)
//         FillImage( row,  col - 1);  //  делаем шаг на лево (от начального пикселя)
//         FillImage( row + 1,  col);  //  опускаемся на строку ниже (от начального пикселя)
//         FillImage( row,  col + 1);  //  шаг на право (от начального пикселя)
//     }
// }
// // Алгоритм работы метода - закрашивает начальный пиксель и проверяет на закрашенность
// // - соседние пиксели (сверху, слева, снизу, справа), если найдет не закрашенный
// // - закрашивает его и проверяет пиксели вокруг него. И т.д.
// PrintImage(pic);  // Выводит отрисованный но не закрашенный массив
// FillImage(7,7);  // Задаем начальный пиксель для метода закраски (должен быть внутри фигуры)
// Console.WriteLine(); // разделение массивов строкой
// PrintImage(pic);  // Отрисовка уже закрашенного массива
// // Метод работает с маленькими картинками, с большими будут проблемы!



// // Вычислить факториал
// // 5!=5*4*3*2*1 -> 5!=5*4!, а 4!=4*3!, а 3!=3*2! и т.д.
// double Factorial(int n)  // целочисленный метод
// {
//     if (n == 1) return 1;  // если n == 1 возвращаем 1
//     // !определение факториала: 1! = 1; кстати 0! = 1.
//     else return n * Factorial(n - 1);
//     // - в противном случае текущее значение умножаем на факториал предыдущего (n - 1)
// }
// //Console.WriteLine(Factorial(4));  // вызов печати факториала 1*2*3*4=24

// for (int i = 1; i < 40; i++)  // вычисление факториалов до 39!
// // тип integer вмещает в себя числа вплоть до 16!, с 17! получается фигня!
// // если требуется расчитать факториал более - меняем тип данных, например на double
// {
// Console.WriteLine($"{i}! = {Factorial(i)}");
// // - печать числа факториала и его значения (таблица факториалов)
// }



// //  Числа Фибоначчи. 
// //  Определение: f(1)=1; f(2)=1; f(n)=f(n-1)+F(n-2)
// int Fibo(int n)  // метод для вычисления чисел Фибоначчи
// {
//     if(n == 1 || n == 2) return 1;  
//     // - если n равно 1 или 2, возвращаем 1;
//     else return Fibo(n-1) + Fibo(n-2);  // - здесь обязательно написать return!
//     // - в противном случае f(n-1)+F(n-2)
// }

// for (int i = 1; i < 50; i++)  // показать первые 50 чисел Фибоначчи
// {
//     // Console.WriteLine(Fibo(i)); // печать только чисел Фибоначчи
//     Console.WriteLine($"f({i}) = {Fibo(i)}");  
//     // Печать таблицы первых 50 чисел Фибоначчи
//     // !После 41 числа метод начинает жостко тупить! Будем разбираться на семинаре.
// }
// // Рекурсия может бять и быстрее и заменена циклом! Будем рассматривать на семинаре.
